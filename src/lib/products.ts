import { 
  collection, 
  addDoc, 
  getDocs, 
  doc, 
  getDoc,
  updateDoc, 
  deleteDoc,
  deleteField,
  query, 
  where,
  orderBy,
  Timestamp 
} from 'firebase/firestore';
import { db } from './firebase';
import { COLLECTIONS, FirestoreProduct, convertFirestoreProduct } from './firestore-types';
import { Product, ProductCategory } from '@/types';
import { deleteMultipleImages } from './storage';

// Dodaj nowy produkt
export const addProduct = async (productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> => {
  try {
    console.log('üîç Debug - Adding product with data:', productData);
    
    // Przygotuj dane - usu≈Ñ undefined fields
    const cleanData: any = {
      name: productData.name,
      description: productData.description,
      category: productData.category,
      availableColors: productData.availableColors,
      images: productData.images,
      mainImage: productData.mainImage,
      isActive: productData.isActive,
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now(),
    };
    
    // Dodaj dimensions tylko je≈õli istniejƒÖ i nie sƒÖ undefined
    if (productData.dimensions) {
      cleanData.dimensions = productData.dimensions;
    }
    
    console.log('üîç Clean data to save:', cleanData);
    
    const docRef = await addDoc(collection(db, COLLECTIONS.PRODUCTS), cleanData);
    
    console.log('‚úÖ Product added successfully with ID:', docRef.id);
    return docRef.id;
  } catch (error: any) {
    console.error('‚ùå Detailed error adding product:', error);
    console.error('‚ùå Error code:', error?.code);
    console.error('‚ùå Error message:', error?.message);
    throw new Error(`Nie uda≈Ço siƒô dodaƒá produktu: ${error?.message || 'Nieznany b≈ÇƒÖd'}`);
  }
};

// Pobierz wszystkie produkty (dla admina)
export const getAllProducts = async (): Promise<Product[]> => {
  try {
    const q = query(
      collection(db, COLLECTIONS.PRODUCTS),
      orderBy('createdAt', 'desc')
    );
    
    const querySnapshot = await getDocs(q);
    const products: Product[] = [];
    
    querySnapshot.forEach((doc) => {
      const data = doc.data() as Omit<FirestoreProduct, 'id'>;
      products.push({
        id: doc.id,
        ...data,
        createdAt: data.createdAt.toDate(),
        updatedAt: data.updatedAt.toDate(),
      });
    });
    
    return products;
  } catch (error) {
    console.error('Error fetching all products:', error);
    throw new Error('Nie uda≈Ço siƒô pobraƒá produkt√≥w');
  }
};

// Pobierz tylko aktywne produkty (dla strony publicznej)
export const getActiveProducts = async (): Promise<Product[]> => {
  try {
    const q = query(
      collection(db, COLLECTIONS.PRODUCTS),
      where('isActive', '==', true),
      orderBy('createdAt', 'desc')
    );
    
    const querySnapshot = await getDocs(q);
    const products: Product[] = [];
    
    querySnapshot.forEach((doc) => {
      const data = doc.data() as Omit<FirestoreProduct, 'id'>;
      products.push({
        id: doc.id,
        ...data,
        createdAt: data.createdAt.toDate(),
        updatedAt: data.updatedAt.toDate(),
      });
    });
    
    return products;
  } catch (error) {
    console.error('Error fetching active products:', error);
    throw new Error('Nie uda≈Ço siƒô pobraƒá produkt√≥w');
  }
};

// Pobierz produkty wed≈Çug kategorii
export const getProductsByCategory = async (category: ProductCategory): Promise<Product[]> => {
  try {
    const q = query(
      collection(db, COLLECTIONS.PRODUCTS),
      where('category', '==', category),
      where('isActive', '==', true),
      orderBy('createdAt', 'desc')
    );
    
    const querySnapshot = await getDocs(q);
    const products: Product[] = [];
    
    querySnapshot.forEach((doc) => {
      const data = doc.data() as Omit<FirestoreProduct, 'id'>;
      products.push({
        id: doc.id,
        ...data,
        createdAt: data.createdAt.toDate(),
        updatedAt: data.updatedAt.toDate(),
      });
    });
    
    return products;
  } catch (error) {
    console.error('Error fetching products by category:', error);
    throw new Error('Nie uda≈Ço siƒô pobraƒá produkt√≥w z kategorii');
  }
};

// Pobierz jeden produkt wed≈Çug ID
export const getProductById = async (productId: string): Promise<Product | null> => {
  try {
    const docRef = doc(db, COLLECTIONS.PRODUCTS, productId);
    const docSnap = await getDoc(docRef);
    
    if (docSnap.exists()) {
      const data = docSnap.data() as Omit<FirestoreProduct, 'id'>;
      return {
        id: docSnap.id,
        ...data,
        createdAt: data.createdAt.toDate(),
        updatedAt: data.updatedAt.toDate(),
      };
    }
    
    return null;
  } catch (error) {
    console.error('Error fetching product:', error);
    throw new Error('Nie uda≈Ço siƒô pobraƒá produktu');
  }
};

// ZAKTUALIZOWANA funkcja updateProduct
export const updateProduct = async (
  productId: string, 
  productData: Partial<Omit<Product, 'id' | 'createdAt'>>
): Promise<void> => {
  try {
    console.log('üîç Updating product:', productId, 'with data:', productData);
    
    const docRef = doc(db, COLLECTIONS.PRODUCTS, productId);
    
    // Sprawd≈∫ czy dokument istnieje
    const docSnap = await getDoc(docRef);
    if (!docSnap.exists()) {
      throw new Error('Produkt nie istnieje');
    }
    
    // Przygotuj dane do aktualizacji - DOK≈ÅADNIE bez undefined
    const cleanData: Record<string, any> = {
      updatedAt: Timestamp.now(),
    };
    
    // Bezpieczne dodawanie p√≥l - tylko te kt√≥re naprawdƒô majƒÖ warto≈õƒá
    if (productData.name !== undefined) {
      cleanData.name = productData.name;
    }
    
    if (productData.description !== undefined) {
      cleanData.description = productData.description;
    }
    
    if (productData.category !== undefined) {
      cleanData.category = productData.category;
    }
    
    if (productData.availableColors !== undefined) {
      cleanData.availableColors = productData.availableColors;
    }
    
    if (productData.images !== undefined) {
      cleanData.images = productData.images;
    }
    
    if (productData.mainImage !== undefined) {
      cleanData.mainImage = productData.mainImage;
    }
    
    if (productData.isActive !== undefined) {
      cleanData.isActive = productData.isActive;
    }
    
    // Specjalna obs≈Çuga dimensions - mo≈ºe byƒá null lub obiekt
    if (productData.dimensions !== undefined) {
      if (productData.dimensions === null) {
        // U≈ºyj deleteField() aby usunƒÖƒá pole
        cleanData.dimensions = deleteField();
      } else {
        cleanData.dimensions = productData.dimensions;
      }
    }
    
    console.log('üîç Clean data to update:', cleanData);
    
    // U≈ºyj updateDoc z bezpiecznƒÖ obs≈ÇugƒÖ b≈Çƒôd√≥w
    await updateDoc(docRef, cleanData);
    
    console.log('‚úÖ Product updated successfully');
  } catch (error: any) {
    console.error('‚ùå Error updating product:', error);
    console.error('‚ùå Error code:', error?.code);
    console.error('‚ùå Error message:', error?.message);
    
    // Lepsze komunikaty b≈Çƒôd√≥w
    if (error?.code === 'not-found') {
      throw new Error('Produkt nie zosta≈Ç znaleziony');
    } else if (error?.code === 'permission-denied') {
      throw new Error('Brak uprawnie≈Ñ do edycji produktu');
    } else if (error?.code === 'invalid-argument') {
      throw new Error('Nieprawid≈Çowe dane produktu');
    } else {
      throw new Error(`Nie uda≈Ço siƒô zaktualizowaƒá produktu: ${error?.message || 'Nieznany b≈ÇƒÖd'}`);
    }
  }
};

// Usu≈Ñ produkt
export const deleteProduct = async (productId: string): Promise<void> => {
  try {
    // Najpierw pobierz dane produktu ≈ºeby mieƒá URLs zdjƒôƒá
    const product = await getProductById(productId);
    
    if (product && product.images && product.images.length > 0) {
      console.log(`Deleting ${product.images.length} images for product ${productId}`);
      
      // Usu≈Ñ wszystkie zdjƒôcia z Firebase Storage
      try {
        await deleteMultipleImages(product.images);
        console.log('Images deleted successfully from storage');
      } catch (storageError) {
        console.error('Error deleting images from storage:', storageError);
        // Kontynuuj mimo b≈Çƒôdu z storage - usu≈Ñ przynajmniej rekord produktu
      }
    }
    
    // Usu≈Ñ rekord produktu z Firestore
    await deleteDoc(doc(db, COLLECTIONS.PRODUCTS, productId));
    console.log('Product deleted successfully from Firestore');
  } catch (error) {
    console.error('Error deleting product:', error);
    throw new Error('Nie uda≈Ço siƒô usunƒÖƒá produktu');
  }
};

// Prze≈ÇƒÖcz status aktywno≈õci produktu
export const toggleProductStatus = async (productId: string): Promise<boolean> => {
  try {
    const product = await getProductById(productId);
    if (!product) {
      throw new Error('Produkt nie znaleziony');
    }
    
    const newStatus = !product.isActive;
    await updateProduct(productId, { isActive: newStatus });
    
    return newStatus;
  } catch (error) {
    console.error('Error toggling product status:', error);
    throw new Error('Nie uda≈Ço siƒô zmieniƒá statusu produktu');
  }
};

// Wyszukaj produkty
export const searchProducts = async (searchTerm: string): Promise<Product[]> => {
  try {
    // Firebase nie ma pe≈Çnego wyszukiwania tekstowego, wiƒôc pobieramy wszystkie aktywne produkty
    // i filtrujemy po stronie klienta
    const products = await getActiveProducts();
    
    return products.filter(product => 
      product.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      product.description.toLowerCase().includes(searchTerm.toLowerCase())
    );
  } catch (error) {
    console.error('Error searching products:', error);
    throw new Error('Nie uda≈Ço siƒô wyszukaƒá produkt√≥w');
  }
};

// Pobierz podobne produkty (z tej samej kategorii)
export const getSimilarProducts = async (productId: string, category: ProductCategory, limit: number = 3): Promise<Product[]> => {
  try {
    const products = await getProductsByCategory(category);
    
    // Usu≈Ñ aktualny produkt i zwr√≥ƒá pierwsze {limit} produkt√≥w
    return products
      .filter(product => product.id !== productId)
      .slice(0, limit);
  } catch (error) {
    console.error('Error fetching similar products:', error);
    throw new Error('Nie uda≈Ço siƒô pobraƒá podobnych produkt√≥w');
  }
};

// Pobierz wyr√≥≈ºnione produkty (najnowsze aktywne)
export const getFeaturedProducts = async (limit: number = 4): Promise<Product[]> => {
  try {
    const products = await getActiveProducts();
    return products.slice(0, limit);
  } catch (error) {
    console.error('Error fetching featured products:', error);
    throw new Error('Nie uda≈Ço siƒô pobraƒá wyr√≥≈ºnionych produkt√≥w');
  }
};

// Pobierz statystyki produkt√≥w
export const getProductsStats = async () => {
  try {
    const allProducts = await getAllProducts();
    const activeProducts = allProducts.filter(p => p.isActive);
    
    // Statystyki wed≈Çug kategorii
    const categoryStats = {} as Record<ProductCategory, { total: number; active: number }>;
    
    allProducts.forEach(product => {
      if (!categoryStats[product.category]) {
        categoryStats[product.category] = { total: 0, active: 0 };
      }
      categoryStats[product.category].total++;
      if (product.isActive) {
        categoryStats[product.category].active++;
      }
    });
    
    return {
      total: allProducts.length,
      active: activeProducts.length,
      inactive: allProducts.length - activeProducts.length,
      byCategory: categoryStats
    };
  } catch (error) {
    console.error('Error getting products stats:', error);
    throw new Error('Nie uda≈Ço siƒô pobraƒá statystyk produkt√≥w');
  }
};